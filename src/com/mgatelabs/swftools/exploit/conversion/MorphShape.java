package com.mgatelabs.swftools.exploit.conversion;

import com.mgatelabs.swftools.exploit.render.AdvancedPath;
import com.mgatelabs.swftools.support.swf.objects.FFill;
import com.mgatelabs.swftools.support.swf.objects.FLine;
import com.mgatelabs.swftools.support.swf.objects.FMorph;

import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.util.Vector;

public class MorphShape {
    // Variables
    public Vector edges;

    public FFill fill;
    public FLine line;

    public int layer;

    public GeneralPath myPath;

    public MorphShape() {
        edges = new Vector();
        fill = null;
        line = null;
        myPath = new GeneralPath();
        layer = 0;
    }

    public void addEdge(RBase aEdge) {
        edges.add(aEdge);
    }

    public static void append(MorphShape morph, MorphShape addOn) {
        for (int x = 0; x < addOn.edges.size(); x++) {
            morph.edges.add(addOn.edges.get(x));
        }

        morph.myPath.append(addOn.myPath, false);
    }

    public static Vector getAdvancedPathVector(FMorph morph, float per) {
        //System.out.println("Getting Paths for " + morph.getRenderData().size() + " morph paths");
        Vector dat = morph.getRenderData();
        Vector result = new Vector(dat.size());

        for (int x = 0; x < dat.size(); x++) {
            result.add(MorphShape.getAdvancedPath((MorphShape) dat.get(x), per));
        }

        return result;
    }

    public static AdvancedPath getAdvancedPath(MorphShape ms, float percentage) {
        //System.out.println("Making AdvancedPath");
        FFill newFill = null;
        FLine newLine = null;

        if (ms.line != null) {
            //System.out.println("Making New Line");
            newLine = ms.line.morph(percentage);
        }

        if (ms.fill != null) {
            //System.out.println("Making New Fill");
            newFill = ms.fill.morph(percentage);
        }

        //System.out.println("Path:" + ms.fill + "/" + ms.line);
        return new AdvancedPath(newFill, newLine, getMorphPath(ms, percentage));
    }

    public static GeneralPath getMorphPath(MorphShape ms, float percentage) {
        //System.out.println("Building Path " + ms.fill + "/" + ms.line);
        //FFill fill = ms.fill;

        GeneralPath path = new GeneralPath();
        PathIterator pi = ms.myPath.getPathIterator(null);
        Vector edges = ms.edges;

        float x1 = 0;
        float x2 = 0;

        float y1 = 0;
        float y2 = 0;

        float cx1 = 0;
        float cx2 = 0;

        float cy1 = 0;
        float cy2 = 0;

        float xd = 0;
        float yd = 0;

        float cxd = 0;
        float cyd = 0;

        float[] floatArray = new float[6];
        boolean keepSkipping = true;

        //System.out.println("Edges " + edges.size());

        for (int x = 0; x < edges.size(); x++) {
            RBase a = (RBase) edges.get(x);
            RBase b = a.getSecondEdge();

            keepSkipping = true;

            // Skip Over Cl
            while (keepSkipping) {
                keepSkipping = false;
                switch (pi.currentSegment(floatArray)) {
                    case PathIterator.SEG_MOVETO: {

                        if (!a.isFlipped()) {
                            x1 = a.getStartX();
                            x2 = b.getStartX();

                            y1 = a.getStartY();
                            y2 = b.getStartY();
                        } else {
                            x1 = a.getStartX();
                            x2 = b.getEndX();

                            y1 = a.getStartY();
                            y2 = b.getEndY();
                        }

                        if (x1 > x2) {
                            xd = x1 - x2;
                            xd = x1 - (xd * percentage);
                        } else {
                            xd = x2 - x1;
                            xd = x1 + (xd * percentage);
                        }

                        if (y1 > y2) {
                            yd = y1 - y2;
                            yd = y1 - (yd * percentage);
                        } else {
                            yd = y2 - y1;
                            yd = y1 + (yd * percentage);
                        }

                        //System.out.println("Move To " + (xd/20.0f) +","+ (yd/20.0f) );
                        path.moveTo((xd / 20.0f), (yd / 20.0f));
                        pi.next();
                    }
                    break;
                    case PathIterator.SEG_CLOSE: {
                        keepSkipping = true;
                        //System.out.println("Close To");

                        //if (fill != null) // Lines don't get to be closed
                        //{
                        path.closePath();
                        //}

                        pi.next();
                    }
                    break;
                    default:
                        //System.out.println("Skipped Line");
                        break;
                }
            }

            //System.out.println("Type : " + a.getType() + " == " + b.getType());

            if (a.getType() == b.getType()) // Just a simple point move
            {
                if (a.isFlipped()) {
                    x1 = a.getEndX();
                    x2 = b.getStartX();

                    y1 = a.getEndY();
                    y2 = b.getStartY();

                    if (x1 > x2) {
                        xd = x1 - x2;
                        xd = x1 - (xd * percentage);
                    } else {
                        xd = x2 - x1;
                        xd = x1 + (xd * percentage);
                    }

                    if (y1 > y2) {
                        yd = y1 - y2;
                        yd = y1 - (yd * percentage);
                    } else {
                        yd = y2 - y1;
                        yd = y1 + (yd * percentage);
                    }


                    if (a.getType() == a.EDGE) {
                        path.lineTo((xd / 20.0f), (yd / 20.0f));
                    } else {
                        RCurve ac = (RCurve) a;
                        RCurve bc = (RCurve) b;

                        cx1 = ac.getControlX();
                        cx2 = bc.getControlX();

                        cy1 = ac.getControlY();
                        cy2 = bc.getControlY();

                        if (cx1 > cx2) {
                            cxd = cx1 - cx2;
                            cxd = cx1 - (cxd * percentage);
                        } else {
                            cxd = cx2 - cx1;
                            cxd = cx1 + (cxd * percentage);
                        }

                        if (cy1 > cy2) {
                            cyd = cy1 - cy2;
                            cyd = cy1 - (cyd * percentage);
                        } else {
                            cyd = cy2 - cy1;
                            cyd = cy1 + (cyd * percentage);
                        }
                        path.quadTo((cxd / 20.0f), (cyd / 20.0f), (xd / 20.0f), (yd / 20.0f));
                    }
                } else {
                    x1 = a.getEndX();
                    x2 = b.getEndX();

                    y1 = a.getEndY();
                    y2 = b.getEndY();

                    if (x1 > x2) {
                        xd = x1 - x2;
                        xd = x1 - (xd * percentage);
                    } else {
                        xd = x2 - x1;
                        xd = x1 + (xd * percentage);
                    }

                    if (y1 > y2) {
                        yd = y1 - y2;
                        yd = y1 - (yd * percentage);
                    } else {
                        yd = y2 - y1;
                        yd = y1 + (yd * percentage);
                    }


                    if (a.getType() == a.EDGE) {
                        path.lineTo((xd / 20.0f), (yd / 20.0f));
                    } else // Curved
                    {
                        RCurve ac = (RCurve) a;
                        RCurve bc = (RCurve) b;

                        cx1 = ac.getControlX();
                        cx2 = bc.getControlX();

                        cy1 = ac.getControlY();
                        cy2 = bc.getControlY();

                        if (cx1 > cx2) {
                            cxd = cx1 - cx2;
                            cxd = cx1 - (cxd * percentage);
                        } else {
                            cxd = cx2 - cx1;
                            cxd = cx1 + (cxd * percentage);
                        }

                        if (cy1 > cy2) {
                            cyd = cy1 - cy2;
                            cyd = cy1 - (cyd * percentage);
                        } else {
                            cyd = cy2 - cy1;
                            cyd = cy1 + (cyd * percentage);
                        }
                        path.quadTo((cxd / 20.0f), (cyd / 20.0f), (xd / 20.0f), (yd / 20.0f));
                    }
                }
            } else // Type Conversion, :(
            {
                RCurve c1 = null;
                RCurve c2 = null;

                if (a.getType() == RCurve.CURVE) {
                    c1 = (RCurve) a;
                } else // Conversion
                {
                    //System.out.println("Converting A");
                    c1 = new RCurve(a.getStartX(), a.getStartY(), a.getEndX(), a.getEndY(), (a.getStartX() + a.getEndX()) / 2, (a.getStartY() + a.getEndY()) / 2);
                    //System.out.println( c1 );
                }

                if (b.getType() == RCurve.CURVE) {
                    c2 = (RCurve) b;
                } else // Conversion
                {
                    //System.out.println("Converting B");
                    c2 = new RCurve(b.getStartX(), b.getStartY(), b.getEndX(), b.getEndY(), (b.getStartX() + b.getEndX()) / 2, (b.getStartY() + b.getEndY()) / 2);
                    //System.out.println( c2 );
                }

                // Copy over code

                if (a.isFlipped()) {
                    x1 = a.getEndX();
                    x2 = b.getStartX();

                    y1 = a.getEndY();
                    y2 = b.getStartY();

                    if (x1 > x2) {
                        xd = x1 - x2;
                        xd = x1 - (xd * percentage);
                    } else {
                        xd = x2 - x1;
                        xd = x1 + (xd * percentage);
                    }

                    if (y1 > y2) {
                        yd = y1 - y2;
                        yd = y1 - (yd * percentage);
                    } else {
                        yd = y2 - y1;
                        yd = y1 + (yd * percentage);
                    }

                    cx1 = c1.getControlX();
                    cx2 = c2.getControlX();

                    cy1 = c1.getControlY();
                    cy2 = c2.getControlY();

                    if (cx1 < cx2) {
                        cxd = cx1 - cx2;
                        cxd = cx1 - (cxd * percentage);
                    } else {
                        cxd = cx2 - cx1;
                        cxd = cx1 + (cxd * percentage);
                    }

                    if (cy1 < cy2) {
                        cyd = cy1 - cy2;
                        cyd = cy1 - (cyd * percentage);
                    } else {
                        cyd = cy2 - cy1;
                        cyd = cy1 + (cyd * percentage);
                    }

                    path.quadTo((cxd / 20.0f), (cyd / 20.0f), (xd / 20.0f), (yd / 20.0f));

                } else {
                    x1 = a.getEndX();
                    x2 = b.getEndX();

                    y1 = a.getEndY();
                    y2 = b.getEndY();

                    if (x1 > x2) {
                        xd = x1 - x2;
                        xd = x1 - (xd * percentage);
                    } else {
                        xd = x2 - x1;
                        xd = x1 + (xd * percentage);
                    }

                    if (y1 > y2) {
                        yd = y1 - y2;
                        yd = y1 - (yd * percentage);
                    } else {
                        yd = y2 - y1;
                        yd = y1 + (yd * percentage);
                    }

                    cx1 = c1.getControlX();
                    cx2 = c2.getControlX();

                    cy1 = c1.getControlY();
                    cy2 = c2.getControlY();

                    if (cx1 < cx2) {
                        cxd = cx1 - cx2;
                        cxd = cx1 - (cxd * percentage);
                    } else {
                        cxd = cx2 - cx1;
                        cxd = cx1 + (cxd * percentage);
                    }

                    if (cy1 < cy2) {
                        cyd = cy1 - cy2;
                        cyd = cy1 - (cyd * percentage);
                    } else {
                        cyd = cy2 - cy1;
                        cyd = cy1 + (cyd * percentage);
                    }

                    path.quadTo((cxd / 20.0f), (cyd / 20.0f), (xd / 20.0f), (yd / 20.0f));
                }
            }

            // Get Next Node
            pi.next();
        }

        if (!pi.isDone()) {
            //System.out.println("Forceing Close");
            path.closePath();
        }

        return path;
    }
}