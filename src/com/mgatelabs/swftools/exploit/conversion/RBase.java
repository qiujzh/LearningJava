/*
    Copyright M-Gate Labs 2007
*/

/**
 <p>
 <b>A Abstract Renderable Edge/Curve</b>
 </p>
 */

package com.mgatelabs.swftools.exploit.conversion;

import com.mgatelabs.swftools.support.swf.objects.FFill;
import com.mgatelabs.swftools.support.swf.objects.FLine;

import java.awt.geom.GeneralPath;

public abstract class RBase {
    private FFill myFill;
    private FLine myLine;
    private boolean flipped;

    private int myID;

    public static final int EDGE = 1;
    public static final int CURVE = 0;

    private int myType;

    private RBase mySecondEdge;

    public RBase(int type, FFill Color, FLine line) {
        myType = type;
        myFill = Color;
        myLine = line;
        flipped = false;
        mySecondEdge = null;
    }


    // Id Entry

    public void setID(int a) {
        myID = a;
    }

    public int getID() {
        return myID;
    }

    // Morph Entries

    public RBase getSecondEdge() {
        return mySecondEdge;
    }

    public void setSecondEdge(RBase aEdge) {
        mySecondEdge = aEdge;
    }

    // Style Entries

    public boolean isSameStyle(RBase b) {
        return myFill == b.getColor() && myLine == b.getLine();
    }

    public boolean isFill() {
        return myFill != null;
    }

    // Sorting Functions

    public boolean touch(RBase b, boolean easy) {
        if ((acceptable(getStartX(), b.getEndX(), easy)) && (acceptable(getStartY(), b.getEndY(), easy))) {
            return true;
        } else if ((acceptable(getEndX(), b.getStartX(), easy)) && (acceptable(getEndY(), b.getStartY(), easy))) {
            return true;
        }
        return false;
    }

    public boolean connect(RBase b, boolean easy) {
        if ((acceptable(getEndX(), b.getStartX(), easy)) && (acceptable(getEndY(), b.getStartY(), easy))) {
            return true;
        }
        return false;
    }

    public boolean connectReverse(RBase b, boolean easy) {
        if ((acceptable(getEndX(), b.getEndX(), easy)) && (acceptable(getEndY(), b.getEndY(), easy))) {
            return true;
        }
        return false;
    }

    public boolean acceptable(long a, long b, boolean easy) {
        return distance(a, b) < (easy ? 4 : 2);
    }

    public long distance(long a, long b) {
        if (a > b) {
            return a - b;
        } else {
            return b - a;
        }
    }

    public boolean cyclic(RBase b) {
        if (getEndX() == b.getEndX() && getEndY() == b.getEndY()) {
            return true;
        } else if (getStartX() == b.getStartX() && getStartY() == b.getStartY()) {
            return true;
        }
        return false;
    }

    // Return my Type, Edge or Curve, no base, we switch

    public int getType() {
        return myType;
    }

    // Get style information

    public FFill getFill() {
        return myFill;
    }

    public FFill getColor() {
        return myFill;
    }

    public FLine getLine() {
        return myLine;
    }

    // Am I a flipped edge, very important

    public boolean isFlipped() {
        return flipped;
    }

    // Get my Start & End

    public abstract long getStartX();

    public abstract long getEndX();

    public abstract long getStartY();

    public abstract long getEndY();

    // get xWidth

    public long getWidth() {
        long a = getStartX();
        long b = getEndX();
        if (a > b) {
            return a - b;
        } else {
            return (b - a);
        }
    }

    public long getHeight() {
        long a = getStartY();
        long b = getEndY();
        if (a > b) {
            return a - b;
        } else {
            return (b - a);
        }
    }

    public long getMidpointX() {
        long width = getWidth();

        long a = getStartX();
        long b = getEndX();

        if (a > b) {
            return b + (width / 2);
        } else {
            return a + (width / 2);
        }
    }

    public long getMidpointY() {
        long height = getHeight();

        long a = getStartY();
        long b = getEndY();

        if (a > b) {
            return b + (height / 2);
        } else {
            return a + (height / 2);
        }
    }

    public long getWidthOffset() {
        long a = getStartX();
        long b = getMidpointX();
        //System.out.println("MidPoint X " + getStartX() + ":" + getEndX() + " = " + b);
        return b - a;
    }

    public long getHeightOffset() {
        long a = getStartY();
        long b = getMidpointY();
        return b - a;
    }

    // Set flip flag

    public void flip() {
        flipped = true;
    }

    // Get my General Path

    public abstract GeneralPath getPath();
}