/*
    Copyright M-Gate Labs 2007
*/

/**
 <p>
 <b>Morph Converter</b>
 </p>
 <p>
 Based off the PRO Converter.  Converts Morphs.
 </p>
 */

package com.mgatelabs.swftools.exploit.conversion;

import com.mgatelabs.swftools.support.swf.objects.*;

import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.util.Vector;

public class MorphConverter implements Converter {
    // Variables

    private int myTotal;
    private int myValue;

    private int myObjectTotal;
    private int myObjectValue;

    private boolean finished;

    private boolean cancel;

    private static final String myStatusMessages[] = {"Processing Shape", "Sorting Edges", "Building Graphs"};

    private int myStatus;

    // Constructor

    public MorphConverter() {
        myStatus = 0;
        myTotal = 0;
        myValue = 0;
        myObjectTotal = 0;
        myObjectValue = 0;
        finished = false;
        cancel = false;
    }

    // Converter Methods

    public String getName() {
        return "Morph Conversion Engine";
    }

    public String getStatus() {
        return myStatusMessages[myStatus];
    }

    public void cancel() {
        cancel = true;
    }

    public int getObjectCount() {
        return myObjectTotal;
    }

    public int getCurrentObject() {
        return myObjectValue;
    }

    public int getValue() {
        return myValue;
    }

    public int getTotal() {
        return myTotal;
    }

    public boolean finished() {
        return finished;
    }

    // Start of update method

    public void update(FMovie anObject) {
        // Convert Shapes
        Vector objects = anObject.getObjectVector();
        myObjectTotal = objects.size();

        for (int x = 0; x < objects.size() && !cancel; x++) {
            myObjectValue = x;
            Object o = (Object) objects.get(x);
            if (!(o instanceof FMorph)) {
                continue;
            }
            FMorph fs = (FMorph) o;

            Vector shapeA = new Vector();
            Vector shapeB = new Vector();
            Vector shapes = new Vector();
            Vector result = new Vector();
            Vector fills = new Vector();
            Vector lines = new Vector();

            update(fs.getStartStyle(), shapeA, fills, lines, true);
            update(fs.getEndStyle(), shapeB, fills, lines, true);

            // Align Data Sets
            for (int y = 0; y < shapeA.size(); y++) {
                Vector sA = (Vector) shapeA.get(y);
                Vector sB = (Vector) shapeB.get(y);
                for (int z = 0; z < sA.size(); z++) {
                    RBase rb = (RBase) sA.get(z);
                    rb.setSecondEdge((RBase) sB.get(0));
                    shapes.add(rb);
                }
            }

            sortPaths(fills, lines, shapes, result);

            fs.setRenderData(result);
            fs.clean();
        }

        finished = true;

        if (!cancel) {
            anObject.setReady(true);
        } else {
            anObject.setReady(false);
        }
    }

    // Get Render Node Information, With ID's

    public void update(FStyle style1, Vector result, Vector fills, Vector lines, boolean create) {
        Vector fillStyles = style1.getFillStyles();
        Vector lineStyles = style1.getLineStyles();

        FFill color1 = null;
        FFill color0 = null;
        FMorphLine line = null;

        for (int x = 0; x < fillStyles.size(); x++) {
            fills.add(fillStyles.get(x));
        }

        for (int x = 0; x < lineStyles.size(); x++) {
            lines.add(lineStyles.get(x));
        }

        // Start the Parsing

        Vector s1 = style1.getShapeRecords();

        int pieceCounter = 0;
        long startX = 0;
        long startY = 0;

        for (int x = 0; x < s1.size(); x++) {
            Object t = s1.get(x);
            //System.out.println(t);

            if (t instanceof FStyleChange) {
                /////////////////////////////////

                FStyleChange aChange = (FStyleChange) t;
                if (aChange.isMoveTo()) {
                    startX = aChange.getMoveDeltaX();
                    startY = aChange.getMoveDeltaY();
                }

                if (aChange.isFillStyle1()) {
                    int temp = aChange.getFillStyle1();
                    if (temp == 0) {
                        color1 = null;
                    } else {
                        color1 = (FFill) fillStyles.get(temp - 1);
                    }
                }

                if (aChange.isFillStyle0()) {
                    int temp = aChange.getFillStyle0();
                    if (temp == 0) {
                        color0 = null;
                    } else {
                        color0 = (FFill) fillStyles.get(temp - 1);
                    }
                }

                if (aChange.isLineStyle()) {
                    int temp = aChange.getLineStyle();
                    if (temp == 0) {
                        line = null;
                    } else {
                        line = (FMorphLine) lineStyles.get(temp - 1);
                    }
                }

                if (aChange.isNewStyles()) {
                    fillStyles = aChange.getFillStyleArray();
                    lineStyles = aChange.getLineStyleArray();

                    for (int y = 0; y < fillStyles.size(); y++) {
                        fills.add(fillStyles.get(y));
                    }

                    for (int y = 0; y < lineStyles.size(); y++) {
                        lines.add(lineStyles.get(y));
                    }
                }

                /////////////////////////////////
            } else if (t instanceof FEdge) {
                /////////////////////////////////

                FEdge aEdge = (FEdge) t;
                long tempX = 0;
                long tempY = 0;

                if (create) {
                    Vector tempVector = new Vector();
                    if (aEdge.getStyle() == aEdge.STRAIGHT) {

                        if (color1 != null && color1 == color0) {
                            // Skip
                            REdge re = new REdge(null, null, startX, startY, aEdge.getDeltaX(), aEdge.getDeltaY());
                            tempX = re.getEndX();
                            tempY = re.getEndY();
                        } else {
                            if (color1 != null) {
                                //System.out.println("Adding Edge  Color 1");
                                REdge re = new REdge(color1, null, startX, startY, aEdge.getDeltaX(), aEdge.getDeltaY());
                                re.setID(aEdge.getID());
                                tempX = re.getEndX();
                                tempY = re.getEndY();
                                tempVector.add(re);
                            }

                            if (color0 != null) {
                                REdge re = new REdge(color0, null, startX, startY, aEdge.getDeltaX(), aEdge.getDeltaY());
                                re.flip();
                                re.setID(aEdge.getID());
                                tempX = re.getStartX();
                                tempY = re.getStartY();
                                tempVector.add(re);
                            }
                        }

                        if (line != null || (line == null && color0 == null && color1 == null)) {
                            //System.out.println("Adding Line");
                            REdge re = new REdge(null, line, startX, startY, aEdge.getDeltaX(), aEdge.getDeltaY());
                            re.setID(aEdge.getID());
                            tempX = re.getEndX();
                            tempY = re.getEndY();
                            tempVector.add(re);
                        }

                        startX = tempX;
                        startY = tempY;
                    } else if (aEdge.getStyle() == aEdge.CURVED) {

                        if (color1 != null && color1 == color0) {
                            //System.out.println("Skipping Curve");
                            RCurve re = new RCurve(null, null, startX, startY, aEdge.getAnchorDeltaX(), aEdge.getAnchorDeltaY(), aEdge.getControlDeltaX(), aEdge.getControlDeltaY());
                            tempX = re.getEndX();
                            tempY = re.getEndY();
                        } else {
                            if (color1 != null) {
                                //System.out.println("Adding Curve Color 1");
                                RCurve re = new RCurve(color1, null, startX, startY, aEdge.getAnchorDeltaX(), aEdge.getAnchorDeltaY(), aEdge.getControlDeltaX(), aEdge.getControlDeltaY());
                                re.setID(aEdge.getID());
                                tempX = re.getEndX();
                                tempY = re.getEndY();
                                tempVector.add(re);
                            }

                            if (color0 != null) {
                                RCurve re = new RCurve(color0, null, startX, startY, aEdge.getAnchorDeltaX(), aEdge.getAnchorDeltaY(), aEdge.getControlDeltaX(), aEdge.getControlDeltaY());
                                re.flip();
                                re.setID(aEdge.getID());
                                tempX = re.getStartX();
                                tempY = re.getStartY();
                                tempVector.add(re);
                            }
                        }

                        if (line != null || (line == null && color0 == null && color1 == null)) {
                            //System.out.println("Adding Line");
                            RCurve re = new RCurve(null, line, startX, startY, aEdge.getAnchorDeltaX(), aEdge.getAnchorDeltaY(), aEdge.getControlDeltaX(), aEdge.getControlDeltaY());
                            re.setID(aEdge.getID());
                            tempX = re.getEndX();
                            tempY = re.getEndY();
                            tempVector.add(re);
                        }

                        startX = tempX;
                        startY = tempY;
                    }
                    result.add(tempVector);
                }

                pieceCounter++;

                /////////////////////////////////
            }
        }
    }

    // Sort Paths

    public void sortPaths(Vector fillStyles, Vector lineStyles, Vector paths, Vector results) {
        myStatus = 1;
        RGraph myGraphs[] = new RGraph[fillStyles.size() + lineStyles.size() + 1];

        for (int x = 0; x < fillStyles.size() + lineStyles.size() + 1; x++) {
            myGraphs[x] = new RGraph(false);
        }

        // Put Each Node into a graph
        myValue = 0;
        myTotal = paths.size();

        for (int x = 0; x < paths.size(); x++) {
            myValue = x;

            if (cancel) {
                return;
            }

            RBase rb = (RBase) paths.get(x);
            if (rb.getFill() != null) // rb.getFill() == rb.getLine() only when both null
            {
                //System.out.println(x + " Fill");
                RNode resultAddNode = myGraphs[(fillStyles.indexOf(rb.getFill()))].addToNodeLibrary(rb, x);
                paths.setElementAt(resultAddNode, x);
            } else if (rb.getLine() != null) {
                //System.out.println(x + " Line");
                RNode resultAddNode = myGraphs[(fillStyles.size() + lineStyles.indexOf(rb.getLine()))].addToNodeLibrary(rb, x);
                paths.setElementAt(resultAddNode, x);
            } else {
                //System.out.println(x + " Null");
                RNode resultAddNode = myGraphs[fillStyles.size() + lineStyles.size()].addToNodeLibrary(rb, x);
                paths.setElementAt(resultAddNode, x);
            }
        }

        // Build Node Connections, One Time, Speed +

        myStatus = 2;
        myValue = 0;
        myTotal = myGraphs.length;
        for (int x = 0; x < myGraphs.length; x++) {
            myValue = x;
            myGraphs[x].setID(x);
            myGraphs[x].buildConnections(false);
        }

        // My New Link List
        MorphLinkList myList = new MorphLinkList();

        // Set Status Flags
        myStatus = 1;
        myValue = 0;
        myTotal = paths.size();

        for (int x = 0; x < paths.size(); x++) {
            RNode aNode = (RNode) paths.get(x);
            myValue = x;
            myStatus = 1;

            if (cancel) {
                return;
            }

            // Don't Check dead Nodes
            if (aNode.isAlive()) {
                RGraph aGraph = aNode.getGraph();

                RNode temp = null;

                int index = aGraph.getID();

                //System.out.println(x + " Locate " + index);

                // Fill Paths
                if (index < fillStyles.size() || (index == (fillStyles.size() + lineStyles.size()))) {
                    //System.out.println("Trying to Add Fill");
                    temp = aGraph.findUseableFillPath(aNode);
                    if (temp != null) {
                        MorphShape ms = convertFill(temp, results);
                        int layer = aGraph.removeChain(temp, true);
                        ms.fill = temp.getObject().getFill();
                        ms.line = null;
                        ms.layer = layer;

                        //System.out.println("Target Layer " + layer);
                        MorphShape targetIfFound = null;

                        // Now I have a layer
                        boolean skipNext = false;
                        MorphLink pNode = myList.getRoot();

                        // Try to join a layer somewhre

                        while (pNode != null) {
                            // Get the Path
                            MorphShape ap = pNode.path; //(AdvancedPath)results.get(y);

                            // Adding Engine

                            if (ap.line == null && ap.fill == temp.getObject().getFill()) {
                                if (ms.myPath.contains(ap.myPath.getCurrentPoint()) || ap.myPath.contains(ms.myPath.getCurrentPoint())) {
                                    if (targetIfFound == null) {
                                        MorphShape.append(ap, ms);
                                        //ap.getPath().append(p, false);
                                        targetIfFound = ap;
                                    } else {
                                        MorphShape.append(targetIfFound, ap);
                                        //targetIfFound.getPath().append( ap.getPath() , false);
                                        MorphLink tempNode = pNode.next;
                                        myList.remove(pNode);
                                        pNode = tempNode;
                                        skipNext = true;
                                    }
                                }
                            }

                            // End Adding Engine

                            ////////////////////

                            // Under Engine

                            if (targetIfFound == null && ap.layer > layer) {
                                myList.addBefore(pNode, ms);
                                ms = null;
                                pNode = null;
                            }

                            // End Under Engine

                            if (skipNext) {
                                skipNext = false;
                            } else if (pNode != null) {
                                pNode = pNode.next;
                            }
                        }

                        // If nothing just add it
                        if (targetIfFound == null && ms != null) {
                            myList.add(ms);
                        }
                    }
                } else // Line Paths
                {
                    temp = aGraph.findUseableLinePath(aNode);
                    //System.out.println( "Finding Useable Line Path" + temp );

                    if (temp != null) {
                        MorphShape ms = convertLine(temp, results);
                        int layer = aGraph.removeChain(temp, false);
                        ms.fill = null;
                        ms.line = temp.getObject().getLine();
                        ms.layer = layer;

                        if (ms != null) {
                            myList.add(ms);
                        }
                    }
                }
            }
        }

        myValue = 0;
        myTotal = 0;

        MorphLink aLink = myList.getRoot();

        while (aLink != null) {
            results.add(aLink.path);
            aLink = aLink.next;
        }
    }

    // End Sort Paths

    // Create Line(Fill) Paths

    public static MorphShape convertLine(RNode root, Vector result) {

        RNode troot = root;
        RGraph myGraph = root.getGraph();

        if (root != null) {
            //System.out.println( "Convert Line" );

            // Go through and build up the Object
            MorphShape aPath = new MorphShape();

            int count = 0;

            while (troot != null) {
                aPath.addEdge(troot.getObject());

                GeneralPath fPath = troot.getObject().getPath();
                if (count == 0) {
                    //System.out.println("Clone");
                    aPath.myPath = (GeneralPath) fPath.clone();
                    count = 1;
                } // End IF
                else {
                    PathIterator pi = fPath.getPathIterator(null);
                    float[] floatArray = new float[6];

                    pi.next(); // Skip Move To

                    while (!pi.isDone()) {
                        //System.out.println("Conversion Path");
                        switch (pi.currentSegment(floatArray)) {
                            case PathIterator.SEG_CLOSE:
                                //System.out.println("Close");
                                aPath.myPath.closePath();
                                break;
                            case PathIterator.SEG_QUADTO:
                                //System.out.println("Quad");
                                aPath.myPath.quadTo(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
                                break;
                            case PathIterator.SEG_LINETO:
                                //System.out.println("Line");
                                aPath.myPath.lineTo(floatArray[0], floatArray[1]);
                                break;
                            case PathIterator.SEG_MOVETO:
                                //System.out.println("Move");
                                aPath.myPath.moveTo(floatArray[0], floatArray[1]);
                                break;
                        } // End Case
                        pi.next();
                    } // End While

                } // End Else

                troot = troot.child;
            }
            return aPath;
        }
        return null;
    }

    // Convert Fill

    public MorphShape convertFill(RNode root, Vector result) {

        RNode troot = root;
        RGraph myGraph = root.getGraph();

        if (root != null) {
            // Go through and build up the Object
            MorphShape aPath = new MorphShape();

            int count = 0;

            while (troot != null) {
                aPath.addEdge(troot.getObject());
                GeneralPath fPath = troot.getObject().getPath();

                if (count == 0) {
                    //System.out.println("Clone Path");
                    aPath.myPath = (GeneralPath) fPath.clone();
                    count = 1;
                } // End IF
                else {
                    //System.out.println("Append Path");
                    PathIterator pi = fPath.getPathIterator(null);
                    float[] floatArray = new float[6];

                    pi.next(); // Skip Move To

                    while (!pi.isDone()) {
                        //System.out.println("Conversion Path");
                        switch (pi.currentSegment(floatArray)) {
                            case PathIterator.SEG_CLOSE:
                                //System.out.println("Close To");
                                aPath.myPath.closePath();
                                break;
                            case PathIterator.SEG_QUADTO:
                                //System.out.println("Quad To");
                                aPath.myPath.quadTo(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
                                break;
                            case PathIterator.SEG_LINETO:
                                //System.out.println("Line To");
                                aPath.myPath.lineTo(floatArray[0], floatArray[1]);
                                break;
                            case PathIterator.SEG_MOVETO:
                                //System.out.println("Move To");
                                aPath.myPath.moveTo(floatArray[0], floatArray[1]);
                                break;
                        } // End Case
                        pi.next();
                    } // End While

                } // End Else

                troot = troot.child;
            }
            //System.out.println("Forced Close");
            aPath.myPath.closePath();
            return aPath;
        }
        return null;
    }
}