/*
    Copyright M-Gate Labs 2007
*/

/**
 <p>
 <b>Render Graph</b>
 </p>
 <p>
 This object holds all the lines and fills for a object.
 Its the CONVERTERS job to sort this mess out.
 </p>
 */

package com.mgatelabs.swftools.exploit.conversion;

import java.util.Vector;

public class RGraph {
    private Vector nodes;
    private Vector normalList;
    private boolean easy;
    private boolean closedPath;
    private int myID;
    private int aliveCount;

    // Setup The Nodes
    public RGraph(boolean easy) {
        closedPath = false;
        nodes = new Vector();
        normalList = new Vector();
        this.easy = easy;
        aliveCount = 0;
    }

    public void setID(int id) {
        myID = id;
    }

    public int getID() {
        return myID;
    }

    // Add Nodes to Graph
    public RNode addToNodeLibrary(RBase re) {
        aliveCount++;
        RNode newNode = new RNode(re, nodes.size(), this);
        nodes.add(newNode);
        return newNode;
    }

    // Add Nodes to Graph
    public RNode addToNodeLibrary(RBase re, int layer) {
        aliveCount++;
        RNode newNode = new RNode(re, layer, this);
        nodes.add(newNode);
        return newNode;
    }

    // Reset Nodes
    public void resetNodes() {
        for (int x = 0; x < nodes.size(); x++) {
            RNode tempA = (RNode) nodes.get(x);
            tempA.reset();
        }
    }

    // Clean Nodes
    public void cleanNodes() {
        for (int x = 0; x < nodes.size(); x++) {
            RNode tempA = (RNode) nodes.get(x);
            tempA.clean();
        }
    }

    // Build Node Links
    public void buildConnections(boolean fillSafe) {
        // Clean Nodes First
        //resetNodes();

        for (int y = 0; y < nodes.size(); y++) {
            RNode tempA = (RNode) nodes.get(y);
            if (tempA.isAlive()) {
                for (int x = 0; x < nodes.size(); x++) {
                    if (x == y) {
                        continue;
                    }

                    RNode tempB = (RNode) nodes.get(x);

                    if (tempB.isAlive() && tempA.getObject().connect(tempB.getObject(), easy)) {
                        tempA.addChild(tempB);
                        tempB.addParent(tempA);
                    }
                    // Fills sould always find a connecting path
                    else if (fillSafe && tempB.isAlive()) {
                        // Only as a last resort
                        if (tempA.getChildCount() == 0 && tempB.getChildCount() == 0) {
                            if (tempA.getObject().connectReverse(tempB.getObject(), easy)) {
                                // Flip the altered line
                                tempB.getObject().flip();

                                System.out.println("Note: Flipping Line");
                                tempA.addChild(tempB);
                                tempB.addParent(tempA);
                            }
                        }
                    }
                }
            }
        }
        //buildNormalList();
    }

    // Return a Node that is Normal

    public RNode getNormalNode(boolean preference) {
        // Clean Nodes First
        //normalList.clear();

        RNode perfered = null;
        RNode possible = null;

        for (int y = 0; y < nodes.size(); y++) {
            RNode tempA = (RNode) nodes.get(y);

            //tempA.parent= null;
            //tempA.child= null;

            if (tempA.isAlive()) {
                //System.out.println("Found Alive");
                if (tempA.isNormal()) {
                    if (possible == null) {
                        possible = tempA;
                        if (!preference) {
                            return possible;
                        }
                    }

                    if (perfered == null && tempA.getParentCount() == 1) {
                        perfered = tempA;
                    }
                }
            }
        }

        if (preference && perfered != null) {
            possible = perfered;
        }

        return possible;
    }


    // public RNode findSelfConnector()
    // {
    // for (int y=0;y<nodes.size();y++)
    // {
    // RNode tempA = (RNode)nodes.get(y);
    //
    // if (tempA.hasChild(tempA.getID()) && tempA.isAlive())
    // {
    // return tempA;
    // }
    // }
    // return null;
    // }

    // How Many Nodes Are Alive
    public int aliveCount() {
        return aliveCount;
    }

    // How Many Nodes Are Alive Line Count
    // Redundent
    public int aliveLineCount() {
        return aliveCount;
    }

    public void destroy() {
        for (int y = 0; y < nodes.size(); y++) {
            RNode tempA = (RNode) nodes.get(y);
            tempA.lockdown();
            aliveCount--;
        }
    }


    // Useful for Debugging
    public void printOutNodeInformation() {
        System.out.println("\nGraph Information");
        for (int x = 0; x < nodes.size(); x++) {
            RNode tempA = (RNode) nodes.get(x);
            System.out.println("\tNode: " + tempA.getID() + " : " + tempA.isAlive() + (tempA.isNormal() ? " Normal " : " Wrong ") + tempA.getObject());

            for (int y = 0; y < tempA.getChildCount(); y++) {
                System.out.println("\t\tChild: " + tempA.getChild(y).getID());
            }

            for (int y = 0; y < tempA.getParentCount(); y++) {
                System.out.println("\t\tParent: " + tempA.getParent(y).getID());
            }
        }
    }

    public boolean isClosedPath() {
        return closedPath;
    }

    public RNode findNode(RBase data) {
        for (int x = 0; x < nodes.size(); x++) {
            RNode e = (RNode) nodes.get(x);
            if (e.getObject() == data) {
                return e;
            }
        }
        return null;
    }

    public RNode findUseableFillPath(RNode root) {
        // Variables
        boolean pathFound = false;

        // Need A Return Root

        RNode current = null;
        RNode child = null;


        // Get the Top Single
        if (root == null) {
            root = getNormalNode(true); // Try to get a root node

            if (root == null) {
                //System.out.println("No Normal NOdes");
                return null;
            }
        }

        //System.out.println("\tFinding Path From " + root.getID() + ", Alive=" + aliveCount());

        // BFS Engine
        Vector currentSearch = new Vector();
        Vector nextSearch = new Vector();
        Vector tempSearch = new Vector();

        // Add Root Children To Next Search

        for (int x = 0; x < root.getChildCount(); x++) {
            ((RNode) root.getChild(x)).parent = root;
            nextSearch.add(root.getChild(x));
        }

        while (nextSearch.size() > 0) {
            tempSearch = currentSearch;
            currentSearch = nextSearch;
            nextSearch = tempSearch;

            //System.out.println("\t\tSearch");

            for (int x = 0; x < currentSearch.size(); x++) {
                // Get the Current Node
                current = (RNode) currentSearch.get(x);
                //System.out.println("\t\t\tChecking " + current.getID());

                for (int y = 0; y < current.getChildCount(); y++) {
                    child = current.getChild(y);

                    if (child.parent == null) {
                        if (child.getID() == root.getID()) {
                            pathFound = true;
                            //System.out.print("\t\t\tFound Root ");
                            while (current.getID() != root.getID()) {
                                // Kill Current Node
                                current.lockdown();
                                aliveCount--;
                                // Set up child pointers
                                //System.out.print(current.getID() + ",");
                                current.parent.child = current;
                                // Move down a node
                                current = current.parent;
                            }
                            aliveCount--;
                            root.lockdown();

                            //System.out.println("");
                            nextSearch.clear();
                            currentSearch.clear();
                            break;
                        } else {
                            //System.out.println("\t\tAdding to Next Search : " + child.getID());
                            child.parent = current;
                            nextSearch.add(child);
                        }
                    }
                }
            }
            currentSearch.clear();
        }

        if (!pathFound) {
            root.lockdown();
            aliveCount--;
            if (root.getObject().connect(root.getObject(), easy)) {//Self Connector, Let it fly.

            } else {
                root = null;
            }
        }

        return root;
    }

    public RNode findUseableLinePath(RNode root) {
        boolean pathFound = false;
        closedPath = false;

        RNode possible = null;
        RNode current = null;
        RNode child = null;

        if (root == null) {
            root = getNormalNode(true);
            //System.out.println("No Node Found");
            if (root == null) {
                for (int x = 0; x < nodes.size(); x++) {
                    //System.out.println("Searching " + x + "/" + nodes.size());
                    root = (RNode) nodes.get(x);
                    if (root != null && root.isAlive()) {
                        break;
                    }
                    root = null;
                }
            }
        }

        if (root == null) {
            return null;
        }

        // BFS Engine
        Vector currentSearch = new Vector();
        Vector nextSearch = new Vector();
        Vector tempSearch = new Vector();

        // Add Root Children To Next Search

        nextSearch.add(root);
        possible = root;

        // for (int x=0;x<root.getChildCount();x++)
        // {
        // ((RNode)root.getChild(x)).parent = root;
        // nextSearch.add(root.getChild(x));
        // possible = root.getChild(x);
        // }

        while (nextSearch.size() > 0) {
            tempSearch = currentSearch;
            currentSearch = nextSearch;
            nextSearch = tempSearch;

            for (int x = 0; x < currentSearch.size(); x++) {
                // Get the Current Node
                current = (RNode) currentSearch.get(x);
                //System.out.println("\t\t\tChecking " + current.getID());

                for (int y = 0; y < current.getChildCount(); y++) {
                    child = current.getChild(y);
                    possible = child;
                    if (child.parent == null) {
                        if (child.getID() == root.getID()) {
                            current.flag = true;
                            pathFound = true;
                            closedPath = true;
                            //System.out.print("\t\t\tFound Root ");
                            while (current.getID() != root.getID()) {
                                // Kill Current Node
                                current.lockdown();
                                aliveCount--;
                                // Set up child pointers
                                current.parent.child = current;
                                // Move down a node
                                current = current.parent;
                            }
                            root.lockdown();
                            aliveCount--;
                            root.flag = true;
                            return root;
                        } else {
                            child.parent = current;
                            nextSearch.add(child);
                        }
                    }
                }
            }
            currentSearch.clear();
        }


        if (possible != null) {
            while (possible.getID() != root.getID()) {
                // Kill Current Node
                possible.lockdown();
                //possible.flag = true;
                aliveCount--;
                // Set up child pointers
                //System.out.print(current.getID() + ",");
                //if ()
                possible.parent.child = possible;
                // Move down a node
                possible = possible.parent;
            }
        }

        root.lockdown();
        aliveCount--;

        return root;
    }

    public int removeChain(RNode root) {
        return removeChain(root, false);
    }

    public int removeChain(RNode root, boolean minimize) {
        RNode current = root;
        RNode future = null;

        int layer = -1;

        if (minimize) {
            layer = root.getID();
        }

        // New Remove Engine
        Vector currentList = new Vector();
        Vector nextList = new Vector();

        //int remove = 0;

        //root.flag = true;

        currentList.add(root);

        while (currentList.size() > 0) {

            for (int x = 0; x < currentList.size(); x++) {
                RNode aParent = (RNode) currentList.get(x);
                aParent.parent = null;

                // Only Worry About Children that link back to me
                for (int y = 0; y < aParent.getChildCount(); y++) {
                    RNode aChild = aParent.getChild(y);
                    if (aChild.parent == aParent) // Links back to me, set for next clearing
                    {
                        nextList.add(aChild);
                        aChild.parent = null;
                    }
                }

                if (aParent.child != null || aParent.flag) {
                    //remove++;
                    if (minimize) {
                        if (aParent.getID() < layer) {
                            layer = aParent.getID();
                        }
                    } else {
                        if (aParent.getID() > layer) {
                            layer = aParent.getID();
                        }
                    }

                    aParent.parent = null;
                    aParent.child = null;
                    aParent.wipe();
                }
            }

            currentList.clear();
            Vector temp = currentList;
            currentList = nextList;
            nextList = temp;
        }

        //System.out.println(remove + "Lines Removes");

        root.parent = null;
        root.child = null;
        root.wipe();

        return layer;
    }

}