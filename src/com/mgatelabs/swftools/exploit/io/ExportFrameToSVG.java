/*
    Copyright M-Gate Labs 2007
*/

/**
 <p>
 <b>Export Frame To SVG</b>
 </p>
 <p>
 Used to Export a single Frame To SVG
 </p>
 */

package com.mgatelabs.swftools.exploit.io;

import com.mgatelabs.swftools.exploit.conversion.MorphShape;
import com.mgatelabs.swftools.exploit.render.AdvancedPath;
import com.mgatelabs.swftools.exploit.render.Clipper;
import com.mgatelabs.swftools.support.swf.objects.*;
import com.mgatelabs.swftools.support.xml.XMLNode;

import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.util.Vector;

public class ExportFrameToSVG {
    private int currentGradient;
    private int currentTexture;
    private int currentClip;
    private String image_pre_name;
    private String image_pre_full_name;
    private XMLNode myDefsNode;

    public ExportFrameToSVG(File target, FMovie rootMovie, FMovieData exportMovie, boolean compress, boolean prettyOutput, boolean zero) {
        // Image Pre-Name
        image_pre_name = target.getName();
        image_pre_name = image_pre_name.substring(0, image_pre_name.lastIndexOf("."));

        image_pre_full_name = target.getPath();
        image_pre_full_name = image_pre_full_name.substring(0, image_pre_full_name.lastIndexOf("."));

        //Setup Variables
        currentGradient = 0;
        currentClip = 0;
        currentTexture = 0;

        XMLNode rootNode = ExportSvgHelper.createSvgHeader(rootMovie);

        myDefsNode = new XMLNode("defs");

        rootNode.addChild(myDefsNode);

        XMLNode myBackgroundNode = new XMLNode("rect");
        myBackgroundNode.addProperty("width", ((rootMovie.getRect().xmax - rootMovie.getRect().xmin) / 20.0f) + "px");
        myBackgroundNode.addProperty("height", ((rootMovie.getRect().ymax - rootMovie.getRect().ymin) / 20.0f) + "px");
        myBackgroundNode.addProperty("x", "0px");
        myBackgroundNode.addProperty("y", "0px");
        myBackgroundNode.addProperty("fill", "#" + convertIntToHex(rootMovie.getBackgroundColor().getRed()) + convertIntToHex(rootMovie.getBackgroundColor().getGreen()) + convertIntToHex(rootMovie.getBackgroundColor().getBlue()));

        rootNode.addChild(myBackgroundNode);

        rootNode.addChild(createLayer(exportMovie.getDisplayList(), null));

        if (zero == true) {
            XMLNode zeroGNode = new XMLNode("g");

            XMLNode zeroNode1 = new XMLNode("path");
            XMLNode zeroNode2 = new XMLNode("path");
            XMLNode zeroNode3 = new XMLNode("path");
            XMLNode zeroNode4 = new XMLNode("path");
            XMLNode zeroNode5 = new XMLNode("path");

            zeroNode1.addProperty("stroke", "#000000");
            zeroNode2.addProperty("stroke", "#000000");
            zeroNode3.addProperty("stroke", "#000000");
            zeroNode4.addProperty("stroke", "#000000");
            zeroNode5.addProperty("stroke", "#000000");

            zeroNode1.addProperty("fill", "none");
            zeroNode2.addProperty("fill", "none");
            zeroNode3.addProperty("fill", "none");
            zeroNode4.addProperty("fill", "none");
            zeroNode5.addProperty("fill", "none");

            zeroNode1.addProperty("d", "M,16.0,-16.0,L,-16.0,16.0");
            zeroNode2.addProperty("d", "M,-16.0,-16.0,L,16.0,16.0");
            zeroNode3.addProperty("d", "M,-32.0,0.0,L,32.0,0.0");
            zeroNode4.addProperty("d", "M,0.0,-32.0,L,0.0,32.0");
            zeroNode5.addProperty("d", "M,-48.0,-48.0,L,-48.0,48.0,L,48.0,48.0,L,48.0,-48.0,L,-48.0,-48.0,Z");

            zeroGNode.addChild(zeroNode1);
            zeroGNode.addChild(zeroNode2);
            zeroGNode.addChild(zeroNode3);
            zeroGNode.addChild(zeroNode4);
            zeroGNode.addChild(zeroNode5);

            rootNode.addChild(zeroGNode);
        }

        if (compress) {
            rootNode.dumpCompressedGZip(target, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n", rootNode);
        } else {
            rootNode.dump(target, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n", rootNode, prettyOutput);
        }
    }

    public ExportFrameToSVG(File target, FMovie rootMovie, Vector exportData, boolean compress, boolean prettyOutput) {
        // Image Pre-Name
        image_pre_name = target.getName();
        image_pre_name = image_pre_name.substring(0, image_pre_name.lastIndexOf("."));

        image_pre_full_name = target.getPath();
        image_pre_full_name = image_pre_full_name.substring(0, image_pre_full_name.lastIndexOf("."));

        //Setup Variables
        currentGradient = 0;
        currentClip = 0;
        currentTexture = 0;

        XMLNode rootNode = ExportSvgHelper.createSvgHeader(rootMovie);

        rootNode.sub = createShape(null, exportData, null);

        if (compress) {
            rootNode.dumpCompressedGZip(target, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n", rootNode);
        } else {
            rootNode.dump(target, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n", rootNode, prettyOutput);
        }
    }

    // Create layers based on the render data
    private XMLNode createLayer(Vector renderData, FDisplayListItem startItem)
    //private XMLNode createLayer(FAffineTransform startMatrix, Area clipping, Vector renderData, FDisplayListItem startItem)
    {

        XMLNode rootNode = new XMLNode("g");

        addOnDisplayProperties(startItem, rootNode);


        FAffineTransform currentMatrix = null;

        String myClipNodeName = null;

        // My Clipping Depth
        int clippingDepth = -1;

        for (int index = 0; index < renderData.size(); index++) {
            FDisplayListItem myItem = (FDisplayListItem) renderData.get(index);

            if (myItem == null) {
                continue;
            }

            String transformString = "";
            if (myItem.getMatrix() != null) {
                transformString = "matrix(";
                transformString += myItem.getMatrix().getScaleX() + " ";
                transformString += myItem.getMatrix().getRotateSkew0() + " ";
                transformString += myItem.getMatrix().getRotateSkew1() + " ";
                transformString += myItem.getMatrix().getScaleY() + " ";
                transformString += myItem.getMatrix().getTranslateX() / 20.0f + " ";
                transformString += myItem.getMatrix().getTranslateY() / 20.0f + ")";
            }

            // Clipping Area

            if (myItem.getClipLayer()) {
                XMLNode clippingNode = new XMLNode("clipPath");
                clippingNode.addProperty("transform", transformString);
                myClipNodeName = "clip" + currentClip;
                currentClip++;


                clippingNode.addProperty("id", myClipNodeName);
                XMLNode clippingData = null;

                Area clipArea = new Area(Clipper.clip(myItem.getObject()));

                clippingData = new XMLNode("path");
                // Move the Shape

                PathIterator pi = clipArea.getPathIterator(null);
                GeneralPath aGPath = new GeneralPath(pi.getWindingRule());
                aGPath.append(pi, false);
                String clippingString = parseGeneralPath(aGPath);

                if (clippingString.length() < 1) {
                    continue;
                }

                clippingData.addProperty("d", parseGeneralPath(aGPath));

                clippingNode.sub = clippingData;

                rootNode.addChild(clippingNode);

                clippingDepth = myItem.getClipDepth() - 1;
            } else {
                if (clippingDepth != -1) {
                    if (clippingDepth < index) {
                        myClipNodeName = null;
                        clippingDepth = -1;
                    }
                }

                if (myItem.isVisible()) {
                    XMLNode aNewNode = null;


                    if (myItem.getObject() instanceof FShape) {
                        FShape fs = (FShape) myItem.getObject();

                        aNewNode = createShape(fs, null, myItem);
                    } else if (myItem.getObject() instanceof FMorph) {
                        FMorph fm = (FMorph) myItem.getObject();

                        aNewNode = createShape(null, MorphShape.getAdvancedPathVector(fm, myItem.getRatio() / 65535.0f), myItem);
                    } else if (myItem.getObject() instanceof FMovieData) {
                        FMovieData fmd = (FMovieData) myItem.getObject();

                        aNewNode = createLayer(fmd.getDisplayList(), myItem);
                    } else if (myItem.getObject() instanceof FText) {
                        FText ft = (FText) myItem.getObject();

                        aNewNode = createText(ft, null, myItem);

                        ft = null;
                    }

                    // See if the new node should be added to the xml
                    if (aNewNode != null) {
                        if (myItem.getMatrix() != null) {
                            aNewNode.addProperty("transform", transformString);
                        }

                        if (myClipNodeName != null) {
                            XMLNode tempClip = new XMLNode("g");
                            tempClip.addProperty("clip-path", "url(#" + myClipNodeName + ")");
                            tempClip.addChild(aNewNode);

                            rootNode.addChild(tempClip);
                        } else {
                            rootNode.addChild(aNewNode);
                        }

                    }

                }
            }
        }

        return rootNode;
    }

    // Create Text Information

    public XMLNode createText(FText aText, Vector data, FDisplayListItem myItem) {
        XMLNode resultNode = new XMLNode("g");
        boolean skipCreation = false;

        XMLNode workNode = resultNode;

        AffineTransform initialTransform = null;

        if (aText.getMatrix() != null) {
            initialTransform = aText.getMatrix().getTransform();
        } else {
            initialTransform = new AffineTransform();
        }

        if (myItem != null) {
            addOnDisplayProperties(myItem, resultNode);
        }

        // Text Variables
        Vector myRecords = aText.getRecords();

        FFont myFont = null;
        FColor myColor = null;
        float offsetX = 0;
        float offsetY = 0;
        float height = 0;
        float myAdvance = 0;

        for (int z = 0; z < myRecords.size(); z++) {
            Object myObject = myRecords.get(z);

            if (myObject instanceof FTextRecord) {
                FTextRecord aRecord = (FTextRecord) myObject;

                if (aRecord.getFont() != null) {
                    myFont = aRecord.getFont();
                    height = aRecord.getHeight() / 20.0f;
                }
                if (aRecord.getColor() != null) {
                    myColor = aRecord.getColor();
                    //g2.setColor(myColor.toColor());
                }
                if (aRecord.hasOffsetX() == false && aRecord.hasOffsetY() == false) {
                    // Skip Advance
                } else {
                    myAdvance = 0;
                    if (aRecord.hasOffsetX()) {
                        offsetX = aRecord.getOffsetX() / 20.0f;
                    }
                    if (aRecord.hasOffsetY()) {
                        offsetY = aRecord.getOffsetY() / 20.0f;
                    }
                }
            } else {

                FTextGlyph aGlyph = (FTextGlyph) myObject;
                if (myFont == null || myFont.getGlyphs() == null) {
                    continue;
                }

                Vector glyphs = (myFont.getGlyphs())[aGlyph.getIndex()];

                GeneralPath path = null;

                AdvancedPath myPath;

                AffineTransform currentTransform = (AffineTransform) initialTransform.clone();

                float myScaleTransform = 1;
                if (myFont.getFormat() == 3) {
                    myScaleTransform = ((height * 100.0f) / (1024.0f)) / 100.0f;
                } else {
                    myScaleTransform = ((height * 100.0f) / (1024.0f / 20.0f)) / 100.0f;
                }

                currentTransform.translate(myAdvance + offsetX, offsetY);

                currentTransform.scale(myScaleTransform, myScaleTransform);

                myAdvance += (float) (aGlyph.getAdvance() / 20.0f);

                for (int a = 0; a < glyphs.size(); a++) {
                    Object gl = glyphs.get(a);
                    if (gl instanceof AdvancedPath) {
                        myPath = (AdvancedPath) glyphs.get(a);
                        path = myPath.getPath();


                        XMLNode tempPath = new XMLNode("path");

                        String imgTransformString = "matrix(";
                        imgTransformString += currentTransform.getScaleX() + " ";
                        imgTransformString += currentTransform.getShearX() + " ";
                        imgTransformString += currentTransform.getShearY() + " ";
                        imgTransformString += currentTransform.getScaleY() + " ";
                        imgTransformString += currentTransform.getTranslateX() + " ";
                        imgTransformString += currentTransform.getTranslateY() + ")";

                        tempPath.addProperty("transform", imgTransformString);

                        tempPath.addProperty("d", parseGeneralPath(path));

                        if (myColor != null) {
                            tempPath.addProperty("fill", "#" + convertIntToHex(myColor.getR()) + convertIntToHex(myColor.getG()) + convertIntToHex(myColor.getB()));
                            if (myColor.getA() < 255 && myColor.getA() > 0) {
                                tempPath.addProperty("opacity", "" + (myColor.getA() / 255.0f));
                            }
                        }

                        resultNode.addChild(tempPath);
                    }
                }
            }
        }

        return resultNode;

    }

    // Create shape information////////////////////////////////////////////////

    public XMLNode createShape(FShape fs, Vector data, FDisplayListItem myItem) {
        XMLNode resultNode = new XMLNode("g");
        boolean skipCreation = false;

        if (myItem != null) {
            addOnDisplayProperties(myItem, resultNode);
        }

        XMLNode trueRootNode = resultNode;

        if (data == null) {
            data = fs.getRenderData();
        }
        //System.out.println("");
        for (int index = 0; index < data.size(); index++) {
            skipCreation = false;
            //System.out.println("Path: " + index);
            AdvancedPath aPath = (AdvancedPath) data.get(index);

            if (aPath.getFill() != null || aPath.getLine() != null || (aPath.getFill() == null && aPath.getLine() == null)) {
                GeneralPath aGPath = aPath.getPath();

                trueRootNode = new XMLNode("path");


                FFill basicFillStyle = aPath.getFill();
                FLine basicLineStyle = aPath.getLine();

                if (basicFillStyle != null) {
                    if (basicFillStyle.getStyle() == FFill.SOLID) {
                        FSolid sfs = (FSolid) basicFillStyle;
                        FColor myColor = sfs.getColor();

                        trueRootNode.addProperty("fill", "#" + convertIntToHex(myColor.getR()) + convertIntToHex(myColor.getG()) + convertIntToHex(myColor.getB()));
                        if (myColor.getA() < 255 && myColor.getA() > 0) {
                            trueRootNode.addProperty("opacity", "" + (myColor.getA() / 255.0f));
                        }
                    } else if (basicFillStyle.getStyle() == FFill.LGRADIENT) {
                        currentGradient++;
                        FGradient gfs = (FGradient) basicFillStyle;

                        // Initial Setup
                        XMLNode myGradientNode = new XMLNode("linearGradient");
                        myGradientNode.addProperty("id", "Grad" + currentGradient);
                        myGradientNode.addProperty("gradientUnits", "userSpaceOnUse");


                        String transformString = "matrix(";
                        transformString += gfs.getMatrix().getScaleX() + " ";
                        transformString += gfs.getMatrix().getRotateSkew0() + " ";
                        transformString += gfs.getMatrix().getRotateSkew1() + " ";
                        transformString += gfs.getMatrix().getScaleY() + " ";
                        transformString += gfs.getMatrix().getTranslateX() / 20.0f + " ";
                        transformString += gfs.getMatrix().getTranslateY() / 20.0f + ")";
                        myGradientNode.addProperty("gradientTransform", transformString);

                        myGradientNode.addProperty("x1", "-819.2");
                        myGradientNode.addProperty("y1", "0");
                        myGradientNode.addProperty("x2", "819.2");
                        myGradientNode.addProperty("y2", "0");

                        // Add to True Node

                        myDefsNode.addChild(myGradientNode);

                        Vector grads = gfs.getGradient();

                        XMLNode tempGradPrevNode = null;


                        for (int x = 0; x < grads.size(); x++) {
                            XMLNode tempGradCurrentNode = new XMLNode("stop");
                            FGradientRecord gr = (FGradientRecord) grads.get(x);
                            FColor gradColor = gr.getColor();

                            tempGradCurrentNode.addProperty("offset", (gr.getRatio() / 255.0f) + "");
                            tempGradCurrentNode.addProperty("stop-color", "#" + convertIntToHex(gradColor.getR()) + convertIntToHex(gradColor.getG()) + convertIntToHex(gradColor.getB()));

                            if (gradColor.getA() < 255) {
                                tempGradCurrentNode.addProperty("stop-opacity", (((gradColor.getA() >= 0) ? gradColor.getA() : 0) / 255.0f) + "");
                            }

                            if (tempGradPrevNode == null) {
                                myGradientNode.sub = tempGradCurrentNode;
                                tempGradPrevNode = tempGradCurrentNode;
                            } else {
                                tempGradPrevNode.next = tempGradCurrentNode;
                                tempGradPrevNode = tempGradCurrentNode;
                            }
                        }
                        trueRootNode.addProperty("fill", "url(#Grad" + currentGradient + ")");
                    } else if (basicFillStyle.getStyle() == FFill.RGRADIENT) {
                        currentGradient++;
                        FGradient gfs = (FGradient) basicFillStyle;

                        // I now have everything needed to make this gradient

                        // Initial Setup
                        XMLNode myGradientNode = new XMLNode("radialGradient");
                        myGradientNode.addProperty("id", "Grad" + currentGradient);
                        myGradientNode.addProperty("gradientUnits", "userSpaceOnUse");

                        String transformString = "matrix(";
                        transformString += gfs.getMatrix().getScaleX() + " ";
                        transformString += gfs.getMatrix().getRotateSkew0() + " ";
                        transformString += gfs.getMatrix().getRotateSkew1() + " ";
                        transformString += gfs.getMatrix().getScaleY() + " ";
                        transformString += gfs.getMatrix().getTranslateX() / 20.0f + " ";
                        transformString += gfs.getMatrix().getTranslateY() / 20.0f + ")";

                        myGradientNode.addProperty("gradientTransform", transformString);

                        myGradientNode.addProperty("r", "819.2");

                        myGradientNode.addProperty("cx", "0");
                        myGradientNode.addProperty("cy", "0");

                        // Add to True Node
                        myDefsNode.addChild(myGradientNode);
                        //myGradientNode.next = resultNode.sub;
                        //resultNode.sub = myGradientNode;

                        Vector grads = gfs.getGradient();

                        XMLNode tempGradPrevNode = null;


                        for (int x = 0; x < grads.size(); x++) {
                            XMLNode tempGradCurrentNode = new XMLNode("stop");
                            FGradientRecord gr = (FGradientRecord) grads.get(x);
                            FColor gradColor = gr.getColor();

                            tempGradCurrentNode.addProperty("offset", (gr.getRatio() / 255.0f) + "");
                            tempGradCurrentNode.addProperty("stop-color", "#" + convertIntToHex(gradColor.getR()) + convertIntToHex(gradColor.getG()) + convertIntToHex(gradColor.getB()));

                            if (gradColor.getA() < 255) {
                                tempGradCurrentNode.addProperty("stop-opacity", (((gradColor.getA() >= 0) ? gradColor.getA() : 0) / 255.0f) + "");
                            }

                            if (tempGradPrevNode == null) {
                                myGradientNode.sub = tempGradCurrentNode;
                                tempGradPrevNode = tempGradCurrentNode;
                            } else {
                                tempGradPrevNode.next = tempGradCurrentNode;
                                tempGradPrevNode = tempGradCurrentNode;
                            }
                        }

                        trueRootNode.addProperty("fill", "url(#Grad" + currentGradient + ")");
                    } else if (basicFillStyle.getStyle() == FFill.TBITMAP || basicFillStyle.getStyle() == FFill.CBITMAP) {
                        FTexture ftex = (FTexture) basicFillStyle;
                        FImage fbit = ftex.getBitmap();

                        //System.out.println("Exporting Bitmap: " + ((FBitmap)fbit).getData());

                        if (fbit == null) {
                            //System.out.println("Could Not Locate Bitmap");
                            continue;
                        }
                        BufferedImage bitmap = fbit.getImage();

                        String bitmapName = null;
                        String bitmapFullName = null;

                        if (fbit instanceof FBitmap && ((FBitmap) fbit).getVersion() < 3) {
                            //System.out.println("Exporting Type: JPG");
                            bitmapName = image_pre_name + "_" + fbit.getID() + ".jpg";
                            bitmapFullName = image_pre_full_name + "_" + fbit.getID() + ".jpg";
                        } else {
                            bitmapName = image_pre_name + "_" + fbit.getID() + ".png";
                            bitmapFullName = image_pre_full_name + "_" + fbit.getID() + ".png";
                        }

                        if ((((fbit instanceof FBitmap) && ((FBitmap) fbit).getData() != null) || ((FBitmap) fbit).getVersion() == 3) || fbit instanceof FLossless) {
                            skipCreation = true;
                            String imgTransformString = "matrix(";
                            imgTransformString += ftex.getMatrix().getScaleX() + " ";
                            imgTransformString += ftex.getMatrix().getRotateSkew0() + " ";
                            imgTransformString += ftex.getMatrix().getRotateSkew1() + " ";
                            imgTransformString += ftex.getMatrix().getScaleY() + " ";
                            imgTransformString += ftex.getMatrix().getTranslateX() / 20.0f + " ";
                            imgTransformString += ftex.getMatrix().getTranslateY() / 20.0f + ")";

                            // Make Clipping Path
                            XMLNode clippingNode = new XMLNode("clipPath");
                            String myClipNodeName = "clip" + currentClip;
                            currentClip++;

                            clippingNode.addProperty("id", myClipNodeName);
                            XMLNode clippingData = null;

                            clippingData = new XMLNode("path");
                            // Move the Shape

                            clippingData.addProperty("d", parseGeneralPath(aGPath));

                            clippingNode.sub = clippingData;

                            myDefsNode.addChild(clippingNode);

                            // Make Image
                            XMLNode myTextureNode = new XMLNode("image");
                            //myTextureNode.addProperty("clip-path","url(#"+myClipNodeName+")");
                            myTextureNode.addProperty("width", fbit.getWidth() + "px");
                            myTextureNode.addProperty("height", fbit.getHeight() + "px");
                            myTextureNode.addProperty("xlink:href", bitmapName);

                            myTextureNode.addProperty("transform", imgTransformString);
                            //myTextureNode.next = resultNode.sub;

                            XMLNode myTextureWrapper = new XMLNode("g");
                            myTextureWrapper.addProperty("clip-path", "url(#" + myClipNodeName + ")");
                            myTextureWrapper.sub = myTextureNode;

                            resultNode.addChild(myTextureWrapper);

                            //resultNode.sub = myTextureWrapper;

                            currentTexture++;

                            try {
                                if (fbit instanceof FBitmap && ((FBitmap) fbit).getVersion() < 3) {
                                    if (((FBitmap) fbit).getData() != null) {
                                        FileOutputStream fos = new FileOutputStream(new File(bitmapFullName));

                                        byte[] bitData = ((FBitmap) fbit).getData();

                                        for (int x = 0; x < bitData.length; x++) {
                                            fos.write(bitData[x]);
                                        }

                                        fos.close();
                                    }
                                } else {
                                    javax.imageio.ImageIO.write(fbit.getImage(), "PNG", new File(bitmapFullName));
                                }
                            } catch (Exception e) {

                            }
                            trueRootNode.addProperty("fill", "none");
                        } else {
                            trueRootNode.addProperty("fill", "#111111");
                        }
                    } else {
                        trueRootNode.addProperty("fill", "#111111");
                    }
                } else if (basicLineStyle != null) {
                    trueRootNode.addProperty("fill", "none");
                    trueRootNode.addProperty("stroke", "#" + convertIntToHex(basicLineStyle.getColor().getR()) + convertIntToHex(basicLineStyle.getColor().getG()) + convertIntToHex(basicLineStyle.getColor().getB()));
                    trueRootNode.addProperty("stroke-width", "" + basicLineStyle.getWidth() / 20.0f);
                }

                trueRootNode.addProperty("stroke-linecap", "round");
                trueRootNode.addProperty("stroke-linejoin", "round");
                trueRootNode.addProperty("d", parseGeneralPath(aGPath));

                if (skipCreation == false) {
                    resultNode.addChild(trueRootNode);
                }
            }
        }
        return resultNode;
    }

    private boolean doesItemExist(XMLNode root, String NodeName, String name, String value) {
        root = root.sub;
        String temp = null;
        while (root != null) {
            if (root.getTitle().equals(NodeName)) {
                temp = root.getProperty(name);
                if (temp != null) {
                    if (temp.equals(value)) {
                        return true;
                    }
                }
            }
            root = root.next;
        }

        return false;
    }

    private void addOnDisplayProperties(FDisplayListItem myItem, XMLNode resultNode) {
        if (myItem != null) {
            CXFORMALPHA aCXFORMALPHA = myItem.getCXFORMALPHA();
            if (aCXFORMALPHA != null) {
                if (aCXFORMALPHA.HasAddTerms()) {
                    //System.out.println("Add");
                    if (aCXFORMALPHA.getAdd(3) > 0 && aCXFORMALPHA.getAdd(3) <= 255) // Just Skip for now
                    {
                        resultNode.addProperty("opacity", "" + (aCXFORMALPHA.getAdd(3) / 255.0f));
                    }

                } else if (aCXFORMALPHA.HasMultTerms()) {
                    //System.out.println("Mul");
                    // Just Worry about Alpha
                    if (aCXFORMALPHA.getMulti(3) > 0 && aCXFORMALPHA.getMulti(3) <= 255) // Just Skip for now
                    {
                        resultNode.addProperty("opacity", "" + (aCXFORMALPHA.getMulti(3) / 255.0f));
                    }
                }
            }
        }
    }

    private String parseGeneralPath(GeneralPath aPath) {
        PathIterator pi = null;

        pi = aPath.getPathIterator(null);

        //PathIterator pi = aPath.getPathIterator(new AffineTransform(), 0.01);
        float[] floatArray = new float[6];

        String tempBuild = "";
        float lastX = 0, lastY = 0;

        while (!pi.isDone()) {

            switch (pi.currentSegment(floatArray)) {
                case PathIterator.SEG_CLOSE:
                    tempBuild = addPartToSvgString(tempBuild, "Z");
                    break;
                case PathIterator.SEG_CUBICTO:
                    tempBuild = addPartToSvgString(tempBuild, "C");
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[0]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[1]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[2]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[3]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[4]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[5]);
                    lastX = floatArray[4];
                    lastY = floatArray[5];
                    break;
                case PathIterator.SEG_QUADTO:
                    // tempBuild = addPartToSvgString(tempBuild,"S");
                    // tempBuild = addPartToSvgString(tempBuild,""+floatArray[0]);
                    // tempBuild = addPartToSvgString(tempBuild,""+floatArray[1]);
                    // tempBuild = addPartToSvgString(tempBuild,""+floatArray[2]);
                    // tempBuild = addPartToSvgString(tempBuild,""+floatArray[3]);

                    // CP1 = QP0 + 2/3 *(QP1-QP0)
                    // CP2 = CP1 + 1/3 *(QP2-QP0)

                    //CP1 = lastX + (2.0f/3.0f) * (floatArray[0]-lastX);
                    //CP2 = CP1 + 1/3 *(QP2-QP0)

                    float cp1x = lastX + (2.0f / 3.0f) * (floatArray[0] - lastX);
                    float cp1y = lastY + (2.0f / 3.0f) * (floatArray[1] - lastY);

                    float cp2x = cp1x + (1.0f / 3.0f) * (floatArray[2] - lastX);
                    float cp2y = cp1y + (1.0f / 3.0f) * (floatArray[3] - lastY);

                    tempBuild = addPartToSvgString(tempBuild, "C");
                    tempBuild = addPartToSvgString(tempBuild, "" + cp1x);
                    tempBuild = addPartToSvgString(tempBuild, "" + cp1y);
                    tempBuild = addPartToSvgString(tempBuild, "" + cp2x);
                    tempBuild = addPartToSvgString(tempBuild, "" + cp2y);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[2]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[3]);

                    lastX = floatArray[2];
                    lastY = floatArray[3];

                    break;
                case PathIterator.SEG_LINETO:
                    tempBuild = addPartToSvgString(tempBuild, "L");
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[0]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[1]);
                    lastX = floatArray[0];
                    lastY = floatArray[1];
                    break;
                case PathIterator.SEG_MOVETO:
                    tempBuild = addPartToSvgString(tempBuild, "M");
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[0]);
                    tempBuild = addPartToSvgString(tempBuild, "" + floatArray[1]);
                    lastX = floatArray[0];
                    lastY = floatArray[1];
                    break;
            }

            pi.next();
        }
        return tempBuild;
    }

    private String addPartToSvgString(String origonal, String part) {
        if (origonal.length() == 0) {
            return part;
        } else {
            char lastChar = origonal.charAt(origonal.length() - 1);
            char newChar = part.charAt(0);

            if (newChar > '0' || newChar < '9') {
                if (lastChar > '0' || lastChar < '9') {
                    return origonal + " " + part;
                } else {
                    return origonal + part;
                }
            } else {
                return origonal + part;
            }
        }
    }

    private String convertIntToHex(int number) {
        int a = number / 16;
        int b = number % 16;

        return getHexChar(a) + getHexChar(b);
    }

    public static String getHexChar(int number) {
        if (number < 10) {
            return "" + number + "";
        } else {
            switch (number) {
                case 10:
                    return "A";
                case 11:
                    return "B";
                case 12:
                    return "C";
                case 13:
                    return "D";
                case 14:
                    return "E";
                case 15:
                    return "F";
            }
        }
        return "?";
    }
}